MEMORY MODEL


Dynamic Allocation is a thing in this language as well as the heap.
So how should segmentation faults be prevented? There are two main problems:

Use after free (UAF)  - this is encountered when something is used after already being deallocated

Memory leaks  - leaking memory is memory that will never be freed, the things in there
                are living for the entire application runtime, which can be bad.

Both problems get prevented by the memory managment strategy. Which goes as follows:

There is just one type of reference in the type system. Its a pointer to something.

    x = 10
    ptr = ->x

When the values are allocated on the heap though:

    ptr = -> malloc(u32)
    reference = -> ptr

A UAF could happen. For example:

    ptr = -> malloc(u32)
    reference = -> ptr
    drop(ptr) // freeing the underlying memory
    print(reference) // access to already cleaned up memory, UAF

To prevent that the references got implicit lifetimes. These explain how long the reference can be
used and at which point it would cause an UAF. They would look like this:

    reference = 'a -> ptr

The lifetime "'a" immediately ends when "ptr" is dropped. In the previous scenario that would cause
the following compile time error:

    ptr = -> malloc(u32)
    reference = -> ptr
    drop(ptr) // freeing the underlying memory
    print(reference) // ERROR: The lifetime of the variable "reference" ended with "drop(ptr)",
                               it can no longer be used in code

For heap allocations a memory responsibility can be attached to a pointer,
making him a responsible reference, which looks like this in code:

    allocator = std.mem.global

    ptr = allocator |> alloc(u32) // ptr is of type "Heap[Global, u32]"

What it does, is, it automatically calls the deallocate function of the allocater ones ptr runs
out of scope. This feature prevents memory leaks pretty well. When it comes to arena allocators, a
pointer to the buffer is needed for freeing. The pointer would be stored in the "Heap" datatype.
Now for the UAF problem. Picture the following scenario:

    arr = vec [1, 2, 3]
    second = -> arr[1]

    arr |> push(4)

    print(second)

Even though it doesnt seem like it, this could cause an UAF.
The problem here is that "push(...)" can cause the vector to reallocate,
when the maximum capacity of the memory location is reached. That would make the reference
"second" invalid.

    arr = vec [1, 2, 3]     // allocation of the vector
    second = -> arr[1]        // creating reference

    arr |> push(4)          // potential reallocate

    print(second)           // UAF

To prevent the error the following rule is enforced:
Things can only be freed by changing the responsible reference. And changing
the responsible reference is only allowed when no other reference to the memory location exists.
When these rules are applied the following error occurs:

    arr = vec [1, 2, 3]
    second = -> arr[1]

    arr |> push(4)

    print(second) // ERROR: Reference second got invalid when .push(..) was called on arr.

If the responsibility has to been moved to a different place, for example into a function, it could cause
an UAF too:

    arr = vec [1, 2, 3]
    foo(arr)
    x = arr[1]

The problem is that "foo" expects an "vec[i32]" which holds the responsibility for the allocated buffer.
Before the "foo" function returns, as it has responsibility, it will cleanup the memory. This means
that the array still assumes the region in the heap exists, while it doesnt. And when for example
the array is read, it would cause an UAF:

    arr = vec [1, 2, 3]
    foo(arr)
    x = arr[1] // UAF

When a pointer with responsibility gets moved, it can not further be read, when not overwritten with
a new value. The process can be thought of as if arr would become uninitialized:

    arr = vec [1, 2, 3]
    foo(arr)
    x = arr[1] // ERROR: The value of arr was moved into foo and can not be read anymore.

The same is applied in any scenario were the responsibility is moved:

    arr = vec [1, 2, 3]
    arr2 = arr
    x = arr[1] // ERROR: The value of arr was moved into arr2 and can not be read anymore.
                         Note: The value of arr is now stored in arr2.

It's not always a good thing to move the responsibility. To prevent this multiple things can be done.
First, not the value itself, but just a reference to it could be given to some function:

    arr = vec [1, 2, 3]
    foo(-> arr) // foo(some_vector -> vec[i32])
    x = arr[1]

Normally this would be a reference to the vectors head, which is stored on the stack. That could also
be inefficient though because it involves indirection:

    some_vector •-,_                                            - stack
                    \_
                      `->  arr: (ptr = •, len = 3, cap = 4)     - stack
                                       \_
                                         `->  1, 2, 3           - heap

A solution is to change the signature of foo:

    foo(some_vector (ptr -> (len * i32), len ux))

Now the function expects a slice. And luckily, "-> arr" will be implicitely transformed into a slice, removing
the indirection and overhead:

    some_vector: (ptr = •, len = 3)          - stack
                         \_
                           `->  1, 2, 3      - heap

But if "foo" needs its own copy of the data and the data shouldnt be moved, it has to be cloned.
That can be done using the build-in function "clone":

    arr = vec [1, 2, 3]
    foo(clone(arr))
    x = arr[1]

If a responsibility has to be explicitely destroyed, the build-in function "drop" can be used:

    arr = vec [1, 2, 3]
    drop(arr)
