PHILOSOPHY


First of all the philosophy tries to be the following: elegant, simple and pragmatic. And in that order.
Going indev its a bit more complicated. Flou views everything as being based on little things, functions,
with certain inputs and certain outputs. The most simple of which being operators: +, -, *, / and so on.
Any occurrence of these is called an expression.

Bindings are abstractions on expressions.

Bindings are the way to access existing expressions. Bindings are not typed, the values are typed. A
binding is bound to its execution path. Expressions are dropped when all the bindings are no longer used.
When an expression is dropped all the bindings cannot be used anymore.

To encapsulate mutability variable bindings are introduced. They are bound to a unique expression by the
compiler when created. These expressions are then uninitilized. When a uninitilized expression is accessed
what happens is called undefined behaviour. Mutating is done with certain operators like: :=, =|=, +=, ++

When it comes to control flow especially pattern matching flow follows a unique approach: pack control
flow into expressions. An example of this is iterating in flow:

    arr[0:..:1] += 2

This would increment every element of the arr by two. The iterator executes the expression n times.
This would be the equivalent in Rust:

    for v in arr.iter_mut() {
        *v += 2
    }

What Flou does is it enhances the natural flow of data in the expression. Hence the name: Flou
The same works for if statements:

    optional = Some(1)

    optional.some += 1

This equals:

    let mut optional = Some(1)

    optional.map(|v| v += 1)

And Flou's version works right of the box for every enum.
