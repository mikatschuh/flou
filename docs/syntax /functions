FUNCTIONS


To understand function interfaces, its first necessary to understand functions and where they come from.
In a program code has to be organised in some way. A general approach is to use functions. They are just code
containers and can be used to abstract things away. On the lowest level, a function just gets called, which means
the execution jumps to the functions code, and then it works with what's currently in the CPU-registers.
For example a function that calculates the dot product of two vectors needs to get the two vectors.
They therefore need to be stored in the register file. The function can afterwards write the result back into
the register file. The exact register file layout differs from CPU to CPU, so the register file has to be abstracted
away. When writing down a function in code, its important to write down what values it expects to be in the registers:

    (a u32, b u32)

The list of values has to have an end and a beginning, brackets seem like a good choice for that. Which type of brackets
though, can be found out looking at how math does it. In math functions got normal parentheses:

    f(a, b) = ...

As a visual seperator, the comma is just the natural choice, this will also be its role in the future. The single values
need a name to tell the caller what they are supposed to represent and a type to determine how the value is being represented.
The name is infront of the type because the name is the most important thing and because name-focused is a charactarisitic
of the language. The function also needs to have an output, what it leaves in the register file when the code jumps back.
And where in the function interface should it be stated how its being
represented, its type? Following the type follows item philosophy from before, the type can be put after the function:

    (a u32, b u32) u32

Though there also needs to be a way of specifing what the function does with the inputs. Again following mathematics,
the name can be put before the parentheses:

    name(a u32, b u32) u32




There was a bit of an evolution going on, with programming languages, when it comes to function signatures.
One of the first types of interfaces is the C-style interface:

    int add(int a, int b);

To be more precise the function-keyword got shorter and shorter over time. Here's what existing languages are up to:

    •- function: JavaScript / TypeScript, PHP, Dart, Swift, Julia, ActionScript, Haxe, Solidity, Hack
    |
    |
    |
    |
    •- func: Go, Nim
    |
    •- fun: Kotlin, Scala, F#, Haskell
    |
    •- fn: Rust, Elixir, ReasonML / ReScript, Zig, V


So first of all: "function" is way too long. "func" is a good idea, as it can clearly be identified
without much context. "fun" is a little weird, as its obviously a reference to the english word "fun". "fn" is the shortest
though being very hard to guess when first encountered. Some languages even have the return type at the start,
like C, C++, Java, C#, D and Vala. That, compared to fn, removes 3 chars from the function signature, not counting the arrow
from Swift or Rust that would get obsolete too. The problem is just that its hard to just look over a file and immediatly know
the core functions. That's because the return-type comes first. And that doesn't say as much about the function itself.
In Thyn there is no function keyword at all:

    foo()

And the return-type, is written with an arrow, if it exists:

    foo() i32

This empty parentheses are really rare, as there are no global variables, everything has to be given as a parameter.
The only real use case is in contructors that need to do stuff at runtime, and in functions that call
functions not written in Thyn - in a language where there is global state. But thats not typical,
so normally its something like that:

    add(a i32, b i32) i32 {}

In this special case you might also want to name the return type:

    add(a i32, b i32) -> c i32 {}

The naming of parameters doesn't work like in Go. "[...]-> c: i32" doesnt means it makes a new variable that can be used,
but just that it returns an integer named c. With other words a struct with one field named c of type i32.
Though this would result in a compile-time error, because the function's signature states it returns something called c,
but there isn't actually a thing returned. To prevent the error:

    add(a i32, b i32) -> c i32 { return c: a + b }

A return statement even has to go there if no data is returned:

    do_nothing(x i32) { return }

But functions are often not enough to organize complex projects. Picture the following scenario:
A large project gets written and to reduce the overall complexity, code gets organized into modules. There has to be
some way of communication between modules. Functions are the obvious answer. And now if multiple people want to work
on modules at the same time the communication, the interface, between modules needs to be clearly defined.
To define that, function signatures are the way to go:

    //============================ mod.thyn ============================
    foo() -> i32
    add(a i32, b i32) -> i32
    combine(a i32, b i32) -> i64

If there aren't actual implementation's of these functions inside of the module, the error logs are comming. These are
a good way to describe the interface. But what about actual interfaces or traits just like in Rust or Go?
To bundle these function signatures into one structure, something called an interface can be used.
It would also be useful to not immediatly enforce them. Looking at the original example, the syntax can be discovered.
By extracting the scope, and pulling it out into a compile-time-constant the signatures get independet of actual
modules:

    example =
    | foo() -> i32
    | add(a i32, b i32) -> i32
    | combine(a i32, b i32) -> i64


So basically just a scope, containing signatures, assigned a name. This makes the signatures independent of specific
implementations. To state that the interface example is implemented, example can just be written out in the module,
as with any function signature:

    //============================ mod.thyn ============================
    example

The interface can also contain other interfaces by writing them out in the interface of course:

    example =
    | foo() -> i32
        add(a i32, b i32) -> i32
        combine(a i32, b i32) -> i64
        other_example
    }

The interface can also be made independet of exact types, using generics:

    Number[T] = {
        new() -> T
        add(self T, other T) -> T
        sub(self T, other T) -> T
        //...
    }

Generics are just squared brackets behind a compile-time-constant, like a function name or any constant really.
To state that Number is implemented for a concrete type, the type-placeholder has to be filled out:

    Number[BigInt]

A use for the interfaces is at functions. A general generic function:

    do_something[T](x T) -> T {}

To constrain T to be of a certain kind of type, interfaces are really useful:

    do_something[T](x T) -> T in Number[T] {}

The "in" keywords can be used. It states that for the following implementation of the thing, this exact interface needs
to be implemented, which happens always implicit.
The function, or anything in general, can have different implementations depending on the exact properties of T:

    do_something[T](x T) -> T in Number[T] {
        // ...
    } in OtherInterface[T] {
        // ...
    }

The syntax for combining multiple contrains can be derived, its just defining an (anonymous) interface like before:

    do_something[T](x T) -> T in {
        Number[T]
        OtherInterface[T]
    } {
        // ...
    }

It comes to mind that actually interfaces are just categories generalized for any Objects with clearly defined Morphisms.
