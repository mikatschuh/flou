ITERATING


Iterating is an important part of programming. Thyn's solution is a bit shorter then
a classical for-loop. The answer is: iterator-chains for everything. But not through the standart library,
but iterating as a language feature. Let's view some examples of iterating and how they
can be solved in Thyn. For example calculating the sum of all elements in an array:

    array = 1, 2, 3, 4, 5

    mut( acc u32 ) := 0
    acc += array[0 : (< 10) : (+1)]

The method to iterate is to index into a array with a mutation. That mutation is used to get the next index.
In this example a "++" mutation is used and it mutates i, which automatically makes i the index used.
The expression, the iteration is part of, is then executed for every item, until i is out of bounds or
an exit statement is met. If some wants to iterate through a linked list they can use the following syntax:

    list = LinkedList [1, 2, 3, 4, 5]

    acc = 0
    acc += [ref = Some (list) : ref := ref.next]

Actually all thats nescessary to iterate are squared brackets. And next is a method of the LinkedList that
mutates ref to get the pointer to the next element, until it failes, meaning it changes the value to not be
in the set of all acceptable values, in this case by setting it to None. Iterating can be combined with pipes too,
just like with anything else. Combined with pipes it looks like this:

    array[i = 0 : i++] |> = val {
        // i is the index and val is the item at that index
    }

Visually this can be thought of as if the pipe would transport a lot of values after each other and
this is Thyn's analog to classical for loops. When this syntax is used in the condition part of
control structure it acts as if the condition would be a regular expression. That means there's no special effect.
