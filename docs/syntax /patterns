PATTERNS


Patterns are a core feature of the language. Their use is to declare variables and
they emerge through the assigment operator. This operator works a little
differently in Thyn in comparison to other languages, because here the assigment operator has the
exact same meaning as in math. To be exact: it can be used to make equations.
Therefore it can also be called equation-operator.
For example, after the statement:

    x = 10

The identifier x equals, in the given scope, 10. Patterns are expressions used as operands
for the equation-operator. In this example, x and 10 are patterns. As said, the operator
works just like in math and that has some useful implications:

    x + 5 = 10

That is a valid statement. The statements only throw errors if the compiler isn't able to
solve the equations. For that example the solution is:

    x = 5

That makes sense and can often times be alot more readable. But implicitely solved equations
have downsides and to limit that, and to not exit the scope of a compiler, the compiler
can only solve those where there's only one solution. More concretly speaking, the rules are
that in every pattern there is at maximum one unknown.
Note: Raising x to n counts as containing x in the pattern n times. -> Theory Of Computational Complexity
For example, this polynom of degree two:

    x^2 + x - 2 = 10 // ERROR: Equation with multiple solutions. If you want to solve the quadratic,
                               you have to do it yourself.

There are two solutions, -4 and 3. An equation is an expression too, as everything is.
Its equal to the value of any of the two sides. Equation-operators can be chained too,
as a shorthand for binding multiple identifiers to the same value:

    a = b = c = 10

So equations in Thyn shall always have exactly one solution. When they got two, the compiler will throw
an error. There is a special case though, that wasn't mentioned until now: if equations dont have
a solution. For example the equation from the beginning, but with a negative solution:

    x + 5 = 4

The solution would be -1 and thats fine if x is an integer. But what if not? If x is a natural number,
in our case an unsigned integer, -1 wouldnt be in the set of all possible states. And that equations
fail like that, can happen at runtime. To cover that case, a fallback has to be provided.
Lets look at a more known example: Enums:

    maybe = None
    Some x = maybe

That equation fails because there isn't a number contained by maybe. Equations that can fail
aren't allowed by the compiler without a fallback. To create a fallback, control structure has to be combined
with equations by putting the equation into the condition-part. For example an if:

    maybe = None
    if Some x = maybe {
        // code that can use x
    } else {
        // code that can't
    }

If the equation fails now, the execution can take another path: the else, where x isnt defined.
Loops are valid fallbacks too:

    loop Some x = maybe {
        // code that can use x
    }

If the equation fails, the loop exits.
