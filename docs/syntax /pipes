PIPES


Pipes are the most powerful feature, though the most complex too, in Thyn. They look like that:

    a |> f()

They can be identified through their operator "|>". The language would pratically function without them,
that means they are just an important addition that makes the difference.
Pipes consist of a chain of things, connected by pipe-operators:

    a |> b |> c

How they work can be imagined as if they would physically transport values as a stack.
The things connected by pipe-operators can have 3 different forms, listed here:

1. Expressions

    They could be just expressions like in the example above. In that case they would put their value
    ontop of the value stack. In the example the queue at the end of the pipe looks like that:

        ==== Top
        c
        b
        a
        ==== Bottom

    Because the stack contains multiple values and cannot be worked into one value again, this would throw an error.

2. Patterns

    To pop a value off the stack, patterns can be combined with pipes.
    To make an expression in a pipe a pattern, the equation-operator can be used here too:

        a |> = b

    b is a pattern in that example. If the pipe is flowing the other way around,
    this form cannot be used. Code that can use the taken value has to be behind the pattern to close it of:

        a |> = b {
            // can use b
        }

    The value taken from the stack gets replaced by that generated by the code block. If the pattern can fail,
    it will just replace the variants it has solutions for, with the value of the code block:

        optional: Maybe[i32] |> = Some: b { b }

    Stack before the pattern:

        ====== Top
        [
            Some: i32,
            None
        ]
        ====== Bottom

    Stack after the pattern:

        ===== Top
        [
            i32,
            None
        ]
        ===== Bottom

    To get a number out of the pipe, the None case has to be handled. So to continue the example:

        optional |> = Some: b { b } |> = None {
            // value if the optional is None
            0
        }

    The stack at the end of the pipe looks like that:

        ===== Top
        [
            i32,
            i32
        ]
        ===== Bottom

    The stack contains one item that is a number in every case. I converges to an i32.
    But we can simplify the pipe. If we leave out the pattern that matches if the optional is Some:

        optional |> = None { 0 }

    We also converge to just an i32 at the end which is possible
    because all variants of the item on the stack have the same type at the end:

        ===== Top
        [
            Some i32,
            i32
        ]
        ===== Bottom

    The example is not quite in the right convention yet though, which goes:

        optional
        |> = None { 0 }

3. Functions

    The third form of something in a pipe is a function with parameters missing. It will take values of the stack
    until it has all its parameters. For example, given a function f:

        f(x i32) -> i32 {
            x^2 + x - 2
        }

    The pipe looks like that:

        x |> f()

    The calling braces are unusual for pipes, in Thyn they are there to differentiate between
    calling a function with values on the stack and putting a function pointer on the stack.

    One use for this is to unravel function call. For example:

        draw_line(render(unwrap(project(unpack(p0)))), render(unwrap(project(unpack(p1)))))

    This is quite unreadable. The order in which the functions are applied is the wrong way for the eye.
    Thats because parameters follow the function name and not the other way around, which is good
    in itself but unpleasent in this specific scenario. After fully it looks like this:

        draw_line(
            p0 |> unpack() |> project() |> unwrap() |> render(),
            p1 |> unpack() |> project() |> unwrap() |> render()
        )

    A bit better at least. And this makes creating variables for intermediate results unnescessary too.
