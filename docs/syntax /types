TYPES


Types are an important part of Flou as its statically typed. There use is in fixed-variables, such as
function arguments and return types and in mutables. The general syntax is:

    VARIABLE TYPE

Flou itselfs has build-in types which resemble bit sequences, also known as numbers.
For example "u32", "i32" or "u64". The u/i at the starts states if the number can also be negative,
So for example a "u32" has a range from 0 - 4294967295. And "i32" on the other side got a range from
-2147483648 - 2147483647. The number after the u/i denotes the number of bits. The number of bits can vary
from 1 to basically infinity, being only constrained by the system's bit width running the compiler.
If instead of u/i an "f" is at the start of the type, the type gets a floating point number, following
the IEEE 754 floating point standart. Valid bit ranges are 16, 32, 64 and 128. The "c" prefix makes
a number type a complex number, except unsigned numbers, those can never be complex. Examples of this are,
"ci32" or "cf32". All the other needed types can be created using the type syntax. Using the -> prefix
operator references too types can be created like so:

    -> u32

The "-" can be expanded to contain more information, like the lifetime of a reference:

    - 'a -> u32

The syntax for this works by just adding an lifetime annotation (an identifier prefixed with an "'")
somewhere before the ">". Note that a between the "'" and the identifier the shall be no space. Some also
like to decorate their reference:

    - - - -  - - 'a - >

To form an array of some type the "*" operator can be used:

    10 * u32

That an array at compile time known to be of length 10. To create a record or a struct curly braces are used:

    { ref ->u32, list 10 * u32 }

The types of the individual fields are denoted behind them, the same as with any typed identifier.
A record can directly be used just like a primitive type:

    mut my_var { a u32, b u32 }

Types can also be tagged. Tagging is a placeholder solution for adding extra information about how
a type should work semantically, it looks like this:

    mut my_var { a u32, b u32 } : Blit

Multiple Tags can also be added:

    mut my_var { a u32, b u32 } : Blit : Serilizable : ...

Tags can also go infront of the type which is preferable sometimes:

    mut my_var Blit : Serilizable : { a u32, b u32 }

To create an own type there are two different syntaxes. One is for shortcuts:

    MyRecord = { a u32, b u32 }

This just works as with any other constant. The shortcut and the original type are equal:

    MyRecord == { a u32, b u32 }

To create a distinct type a syntax without the equation operator has to be used:

    MyRecord { a u32, b u32 }

This is now not equal to the underlying record:

    MyRecord != { a u32, b u32 }

It is distinct. Distinct types have their tags attached to their names:

    MyRecord : Copy { a u32, b u32 }

To complete the algebraic datatypes enums are needed too. To make records that can have
multiple varients the "|" operator can be used.

    MyEnum | MyVariant1
           | MyVariant2
           | MyVariant3

MyVariant one to three are untyped components. That makes it carry a value depending on which
variant is activ. The different values can also explicitely assigned:

    MyEnum | MyVariant1 = 0
           | MyVariant2 = 1
           | MyVariant3 = 2

Sometimes before the variants is prefered or to type them:

    MyEnum | 0_u64 = MyVariant1
           | 1_u64 = MyVariant2
           | 2_u64 = MyVariant3

Or even without naming the variants:

    MyEnum | 0_f32
           | 1_f32
           | 2_f32

It doesn't matter. Its just important that there exist fixed values that allow the compiler
to differentiate. To add payload to variants the space behind them can be used:

    MyEnum | 0, a u32, b u32
           | 1, a i32
           | 2, a 128

As seen the variants can have different sizes. The total size is just the maximal size of all variants.
Existential types are ones that types that.
