How should it work? There should be a tree and a mutable reference should be given
to the token - pushing - units. Over time a promise builds up. For example:

a -> fn(, b)

The arrow promisses that there will be a free space where a value can be pushed in.
That example should resolve in:

fn(a, b)

If the promise isn't satisfied like in this situation:

a -> fn(b)

There wouldnt be a free space where a can be pushed in. In that case an error
should be returned:

Error  an arrow was used, but there weren't a free space where it could be pushed in [..]

There is a scenario that allows this kind of behavior (it can be handled):

a: int -> int

This describes a function type by using an deklaration "a: int" and an arrow pointing
to an expression "int" with no free space.

a: int -> ()

This is another case but it resolves in:

( a: int )

That is because there is a free space and its therefore not a function type anymore.
